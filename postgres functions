/*********************get slotcount for the given doctorID and given weekday ********************************/

CREATE OR REPLACE FUNCTION GetSlotCountForDoctor(docid integer, weekday integer)
RETURNS integer AS $$
DECLARE
    slot_count integer := 0;
    slot_record RECORD;  -- Declare a record variable outside the loop
BEGIN
    -- Iterate through doctor's available time slots
    FOR slot_record IN
        SELECT
            "doctorid",
            "doctorslotindex",
            "doctoravailablefrom"::time,
            "doctoravailableto"::time,
            "doctoravailableslot",
            "doctorschedule"
        FROM
            T2_doctorschedule 
        WHERE
            "doctorid" = docid
    LOOP
        -- Check if the specified weekday is included in the doctor's schedule
        IF position(weekday::text in slot_record.doctorschedule) > 0 THEN
            -- Calculate the slot intervals
            FOR i IN 0..((EXTRACT(EPOCH FROM (slot_record.doctoravailableto - slot_record.doctoravailablefrom)) / 60) / slot_record.doctoravailableslot - 1)::integer
            LOOP
                -- Increment the slot count
                slot_count := slot_count + 1;
            END LOOP;
        END IF;
    END LOOP;
    
    -- Return the slot count
    RETURN slot_count;
END;
$$ LANGUAGE plpgsql;





/****************************************getslotsfor the given docid and date from appointmentsslotcalendar******************************************/


create or Replace function getslotcountperdate(doctor_id integer,slot_date DATE)
returns integer as $$

Declare 
   res integer :=0;
BEGIN
	select count(*) into res  
	from appointmentsslotcalendar 
	where slotdoctorid=doctor_id 
	and slotdate=slot_date;
	
	return res;
END;
$$ LANGUAGE plpgsql;


select getslotcountperdate(6,'2023-09-25')

select * from appointmentsslotcalendar where slotdoctorid=6 and slotdate='2023-09-25'


/**********************************************procedure `1********************************/

select * from appointmentsslotcalendar;

select * from doctorschedule_bhaskar;



select * from GenerateAppointmentSlot(5,'2023-09-05');


CREATE OR REPLACE FUNCTION GenerateAppointmentSlot(doctor_id INT, today_date DATE) RETURNS VOID AS $$
DECLARE
    slot_exists INT;
    next_date DATE;
    current_day_of_week INT;
    res BOOLEAN;
    day_to_check TEXT;
BEGIN
    -- Check if a slot already exists for the current date
    SELECT COUNT(*) INTO slot_exists
    FROM appointmentsslotcalendar
    WHERE slotdoctorid = doctor_id AND slotdate = today_date;

    IF slot_exists > 0 THEN
        -- Slot already exists, increment the date by one day
        next_date := today_date + 1;
        PERFORM GenerateAppointmentSlot(doctor_id, next_date);
    ELSE
    	current_day_of_week := EXTRACT(ISODOW FROM today_date);
    	-- Convert the current day of the week to a string to match the format in doctorschedule
        day_to_check := current_day_of_week::TEXT;

        -- Check if the day_to_check is present in doctorschedule
        SELECT EXISTS (
            SELECT 1
            FROM doctorschedule_bhaskar
            WHERE doctorid = doctor_id AND POSITION(day_to_check IN doctorschedule) > 0
        ) INTO res;

        IF res THEN
            -- Doctor is available, generate the slot
            PERFORM create_slots_for_doctor(doctor_id, today_date);
            -- You may want to commit the transaction here if needed
        ELSE
            -- Doctor is not available on the current date
            -- You can add error handling or return a message as needed
            RAISE EXCEPTION 'Doctor is not available on the current date';
        END IF;
    END IF;
END;
$$ LANGUAGE PLPGSQL;





